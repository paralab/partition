\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}

\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage{algpseudocode}

\algrenewcommand\algorithmicindent{10pt}%

\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}

% TODO: remove the following in the final
\usepackage{lipsum}  

\begin{document}

\title{Conference Paper Title*\\
{\footnotesize \textsuperscript{*}Note: Sub-titles are not captured in Xplore and
should not be used}
\thanks{Identify applicable funding agency here. If none, delete this.}
}

\author{\IEEEauthorblockN{1\textsuperscript{st} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{3\textsuperscript{rd} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{4\textsuperscript{th} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{5\textsuperscript{th} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{6\textsuperscript{th} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
}

\maketitle

\begin{abstract}
    \lipsum[1-1]
\end{abstract}

\begin{IEEEkeywords}
keyword1, keyword2, keyword2
\end{IEEEkeywords}

\section{Introduction}
\lipsum[1-1]

\section{Definitions}
\lipsum[1-1]

\section{Related Work}

\subsection{Work 1}

\lipsum[1-1]
\cite{parmetis}

\subsection{Work 2}

\lipsum[1-1]

\section{Methodology}
In this section we outline the data structures and key routines for BFS-partition.


\subsection{Data Structures}
Similar to other mesh partitioning algorithms based on graphs, BFS partition algorithm requires the mesh element connectivity to be presented as a graph data structure. We adhere to commonly used distributed CSR graph encoding as the graph input format to the algorithm. Apart from the graph adjacency structure, the only other data structures needed inside the BFS algorithm are, the \verb|bfs_vec| and the \verb|scatter_map|.
\par
In each process, \verb|bfs_vec| is the vector to store the BFS status of each local vertex and each ghost vertex. \verb|bfs_vec| adheres to the initial indexing of the vertices provided by the user. Each entry in the \verb|bfs_vec| contains two fields: 
\begin{enumerate}
    \item \verb|label| = Assigned new partition label
    \item \verb|distance| = Distance from the seed of the current partition
\end{enumerate}
\par
Initially \verb|label| is set as \verb|NO_LABEL| implying the vertex is not visited by BFS. In each process, BFS vector entries corresponding to the ghost vertices are kept at one contiguous section in the \verb|bfs_vec|, referred to as the ``ghost portion''. Ghost portion of the BFS vector is partitioned according to the owning processes of ghost vertices. Thus, the ghost portion of the BFS vector is directly used as the ghost receive buffer for subsequent synchronization in BFS rounds. Each process maintains a \verb|scatter_map| for sending updated values to ghost processes. The \verb|scatter_map| in each process is created only once and repeatedly used for the communication in the BFS process.

% TODO: add BFS vector illustration with ghost portion and scatter map

\subsection{Algorithm}
Given the data structures, high level outline of the BFS partition algorithm is given in Fig. \ref{algo:bfs-par-outline}. BFS partition algorithm requires some initial distribution of the graph across distributed processes. The initial distribution needs to have some locality in the graph vertices in each process. Therefore, SFC type partitioning of the input mesh is ideal for the initial distribution. If the graph needs to be partitioned to $p$ parts, we assume the graph is initially distributed across $p$ processes. In each process, a vertex is picked as the local BFS \emph{seed}. Since the mesh/graph is initially partitioned according to the SFC ordering, we take the \emph{middle} (in SFC order) vertex in each process as the \emph{seed} in that process. Each \emph{i}th \emph{seed} $(i \in [0, p-1])$ at process $i$ starts $i$th BFS exploring the graph structure in a BFS pattern. When exploring the graph, the BFS vector entry of each visited vertex is populated as \verb|label|=$i$ and \verb|distance|=\emph{graph distance from seed i}. If any $i$th BFS encounters an already visited vertex, the following takes place. If the current \verb|distance| value of the vertex is greater than the distance from $i$th seed, it is re-visited by $i$th BFS and updates its \verb|distance| and \verb|label| fields. Otherwise, that vertex is not re-visited by $i$th BFS. This process continues until there is no change to the BFS vector globally. In this way, each vertex gets their \verb|label| based on the closest seed. The \verb|label| field is the assignment in the final partitioning.
\par
The implementation is done using 2 main procedures. \verb|BFS-Round()| and \verb|Ghost-Update()| procedures are repeatedly applied until the global BFS state is stable across all processes. \verb|Ghost-Update()| uses the pre-computed \verb|scatter_map| to prepare the sending buffer. BFS vector is updated with the received ghost values accordingly. Subsequent element/graph redistribution is done by accessing the computed \verb|distance| field in the BFS vector.

\begin{figure}  
    \begin{algorithmic}[1]  
    \Procedure{BFS-Partition}{$local\_graph$}  
    \State $bfs\_vec \gets$ Vector(size: $local\_graph.vertex\_count$)
    \State $mid \gets (local\_graph.own\_vertex\_count) /2$
    \State $bfs\_vec[mid].label \gets $ MPI\_rank
    \State $bfs\_vec[mid].distance \gets 0$
    \State $global \gets $ true
    \While{$global$}
        \State $global \gets $ false
        \State {$local \gets $ \Call{BFS-Round}{$local\_graph$, $bfs\_vec$}}
        \State \Call{Update-Ghost}{}()
        \State $global \gets$ \Call{MPI-Reduce}{$local$, LOGICAL\_OR}
    \EndWhile
    \State \textbf{return} $bfs\_vec$
    
    \EndProcedure  
    \end{algorithmic}

    \vspace{10pt}

    \begin{algorithmic}[1]  
    % \Procedure{BFS-Initial}{$local\_graph$, $bfs\_vec$}
    
    % \State $mid \gets (local\_graph.own\_vertex\_count) /2$
    % \State \Comment{\emph{SFC mid as the seed}}
    % \State $dist \gets 0$
    % \State $bfs\_vec[mid].label \gets $ MPI\_rank
    % \State $bfs\_vec[mid].distance \gets dist$
    % \State $bfs\_q \gets $ Queue()
    % \State $bfs\_q.enqueue(mid)$
    % \While {$bfs\_q \neq \emptyset$ }
    %     \State $dist = dist + 1$
    %     \State $v \gets bfs\_q.dequeue()$
    %     \ForAll{$u \in local\_graph.neighbors(v)$}
    %         \If{$bfs\_vec[u].label == $ NO\_LABEL}
    %             \State $bfs\_vec[u].label \gets $ MPI\_rank
    %             \State $bfs\_vec[u].distance \gets dist$
    %             \State $bfs\_q.enqueue(u)$
    %         \EndIf
    %     \EndFor

    % \EndWhile

    % \EndProcedure  

    \vspace{10pt}


    \Procedure{BFS-Round}{$local\_graph$, $bfs\_vec$}
    \State $changed \gets $ false
    \State $not\_stable \gets $ true

    \While{$not\_stable$}
        \State $not\_stable \gets $ false
        
        \State $bfs\_vec\_temp \gets bfs\_vec$.copy()
        \ForAll{$v \in local\_graph.vertices$}
        \State $best\_dist \gets bfs\_vec[v].distance$
        \State $best\_label \gets bfs\_vec[v].label$ 
            \ForAll{$u \in local\_graph.neighbors(v)$}
            \If{$best\_label ==$ NO\_LABEL \textbf{or} ($bfs\_vec[u].label \neq$ NO\_LABEL \textbf{and} $best\_dist > bfs\_vec[u].distance + 1 $)}
                \State $best\_dist \gets bfs\_vec[u].distance + 1$
                \State $best\_label \gets bfs\_vec[u].label$
                \State $not\_stable \gets $ true
                \State $changed \gets $ true

            \EndIf
            \EndFor
        \State $bfs\_vec\_temp[v].distance \gets best\_dist$
        \State $bfs\_vec\_temp[v].label \gets best\_label$

        \EndFor
        \State $bfs\_vec \gets bfs\_vec\_temp$
    \EndWhile
    \State \textbf{return} $changed$
    \EndProcedure


    \end{algorithmic}  
    \caption{BFS partition algorithm outline}  
    \label{algo:bfs-par-outline}  
\end{figure}

\subsection{Optimizations}
In \verb|BFS-Round()| procedure, each \verb|while| loop iteration evaluates all the vertices and their neighborhoods. Since BFS flows similar to a frontier in the graph, it is sufficient to check and update the neighborhoods of the last updated vertices. To implement this, \verb|Update-Ghost()| is modified to return the list of vertices that were updated in the last ghost value exchange. Thereafter, \verb|BFS-Round()| proceeds to check only the neighborhood vertices of the last updated vertices. Furthermore, \verb|Update-Ghost()| is optimized to compare the current send buffer with the last send buffer to send only the updated values.

% \subsection{A list}
% \begin{itemize}
% \item \lipsum[1][1]
% \item \lipsum[1][1]
% \item \lipsum[1][1]
% \end{itemize}

% \subsection{Equations}

% \begin{equation}
% a+b=\gamma\label{eq}
% \end{equation}

% Be sure that the 
% symbols in your equation have been defined before or immediately following 
% the equation. Use ``\eqref{eq}'', not ``Eq.~\eqref{eq}'' or ``equation \eqref{eq}'', except at 
% the beginning of a sentence: ``Equation \eqref{eq} is . . .''

% \subsection{\LaTeX-Specific Advice}

% Please use ``soft'' (e.g., \verb|\eqref{Eq}|) cross references instead
% of ``hard'' references (e.g., \verb|(1)|). That will make it possible
% to combine sections, add equations, or change the order of figures or
% citations without having to go through the file line by line.

% Please don't use the \verb|{eqnarray}| equation environment. Use
% \verb|{align}| or \verb|{IEEEeqnarray}| instead. The \verb|{eqnarray}|
% environment leaves unsightly spaces around relation symbols.

% Please note that the \verb|{subequations}| environment in {\LaTeX}
% will increment the main equation counter even when there are no
% equation numbers displayed. If you forget that, you might write an
% article in which the equation numbers skip from (17) to (20), causing
% the copy editors to wonder if you've discovered a new method of
% counting.




% \subsection{Figures and Tables}
% \paragraph{Positioning Figures and Tables} Place figures and tables at the top and 
% bottom of columns. Avoid placing them in the middle of columns. Large 
% figures and tables may span across both columns. Figure captions should be 
% below the figures; table heads should appear above the tables. Insert 
% figures and tables after they are cited in the text. Use the abbreviation 
% ``Fig. \ref{fig}'', even at the beginning of a sentence.

% \begin{table}[htbp]
% \caption{Table Type Styles}
% \begin{center}
% \begin{tabular}{|c|c|c|c|}
% \hline
% \textbf{Table}&\multicolumn{3}{|c|}{\textbf{Table Column Head}} \\
% \cline{2-4} 
% \textbf{Head} & \textbf{\textit{Table column subhead}}& \textbf{\textit{Subhead}}& \textbf{\textit{Subhead}} \\
% \hline
% copy& More table copy$^{\mathrm{a}}$& &  \\
% \hline
% \multicolumn{4}{l}{$^{\mathrm{a}}$Sample of a Table footnote.}
% \end{tabular}
% \label{tab1}
% \end{center}
% \end{table}

% \begin{figure}[htbp]
% \centerline{\includegraphics{figures/fig1.png}}
% \caption{Example of a figure caption.}
% \label{fig}
% \end{figure}

\section{Experimental Results}
We present experimental results for two aspects of the partitioning algorithm, (1) scalability and performance, and (2) partition quality. We compare our results with three other commonly used mesh partitioning schemes, (1) SFC method, (2) parMETIS algorithm and (3) PT-Scotch algorithm. We evaluate the three methods using a collection of mesh files. Elements (tet or hex) in each mesh first partitioned using the three different partitioning schemes. Further experiments on partition quality are performed on the new partition labels on elements.

\subsection{Hardware Setup}

\subsection{Input Files}
We used 3D mesh file collection from \cite{meshes}. The collection contains both hexahedra meshes and tetrahedra meshes. We present experiment results for 50 meshes. Figures are presented for a selected 10 mesh files.


\subsection{Scalability and Performance}
Since BFS algorithm is a local operation, BFS partitioning is highly scalable in distributed memory environment. Furthermore, the number of rounds needed for BFS partitioning (until BFS global stability is reached) is observed to be nearly constant regardless of the number of required partitions. These two observations contribute to the near linear strong scalability of BFS partition method. All 3 methods: BFS, parMETIS and PT-Scotch require the mesh as a distributed graph structure. Initial distribution was obtained using SFC partitioning. Fig TODO shows strong scalability results with selected 10 mesh files. Graph setup time and subsequent re-distribution time are omitted since those values are similar across all three methods in the comparison. While both parMETIS and PT-Scotch fail to achieve reasonable scalability, BFS partition shows near linear scalability for sufficiently larger input meshes. Although BFS partition shows poor scalability for smaller meshes, performance is consistently better than partMETIS and PT-Scotch, factor of 10 and 100 respectively.


\subsection{Partition Quality}
We present the partition quality data using the following criteria
\begin{itemize}
    \item number of boundary elements in each partition 
    \item $\lambda = $ ratio of total number of boundary elements to all elements
    \item $\rho_{max}$ size of the largest partition size relative to ideal partition size
\end{itemize}

Fig. TODO shows the distribution of the boundary size of each partition. BFS partition boundary distribution is significantly better than SFC partitioning. Since BFS is a local operation, we can not expect the BFS partitioning to be better than parMETIS or PT-Scotch. However, the median boundary size of BFS partitioning is comparable with parMETIS and PT-Scotch. Fig. TODO shows $\lambda$ for the all four partitioning methods. BFS partitioning consistently maintains $\lambda$ close to parMETIS and PT-Scotch. Fig. TODO presents $\rho_{max}$ for all partitioning methods. Since BFS partitioning relies on graph distance for partition assignment, there is no explicit control or constraint of the partition sizes. Therefore, the partition size distribution of BFS is worse than all other three methods. However, $\rho_{max}$ in BFS is consistently within 2-2.5 range. This might appear as a bad size for partitioning. However, in most real-world very large scale scientific computations that involve distributed partitioning, improvements in the boundary size can compensate for a slight imbalance in partition size. When such computations are scaled up for very large number of distributed processes, network communication often hinders the strong scalability. Communication cost is directly proportional to the boundary size of the partitions. Therefore, any significant improvement in boundary quality can improve the strong scalability. In most cases improvement of the communication can compensate for the local extra work caused by a slight imbalance in the partitions. In the next section we present empirical data to support this claim.

\subsection{Linear Solver test}
We present a linear solver test on the new partitioning to show that BFS partitioning is truly useful in real-world scientific computations. Since we use mesh files as inputs, we use a linear solver on top of FEM like model on the nodes of the input mesh. After partitioning the 3D elements, nodes of each element are also assigned to a partition as follows. If a node is contained in only one element, node's partition is same as that element's partition. Otherwise, out of all the partitions of all the containing elements, the least numbered partition is considered as the node's partition. After node partitioning, elemental matrices are created with some dummy scalar values to generate the global sparse matrix. We use PETsc \cite{petsc-web-page} for global matrix assembly and linear solver. Fig. TODO shows the time taken for PETsc GMRES \cite{GMRES} iterative solver for the four partitioning results. This experiment shows that a significant improvement in partition boundary quality in the BFS partitioning can compensate for the slight imbalance in the partition sizes. When the linear solver is scaled-up to higher number of processes, BFS partitioning results in good strong scalability in the linear solver, close to parMETIS and PT-Scotch. 




\section*{Acknowledgment}

The preferred spelling of the word ``acknowledgment'' in America is without 
an ``e'' after the ``g''. Avoid the stilted expression ``one of us (R. B. 
G.) thanks $\ldots$''. Instead, try ``R. B. G. thanks$\ldots$''. Put sponsor 
acknowledgments in the unnumbered footnote on the first page.

% \section*{References}


\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,main-bib.bib}

\vspace{12pt}
\color{red}
IEEE conference templates contain guidance text for composing and formatting conference papers. Please ensure that all template text is removed from your conference paper prior to submission to the conference. Failure to remove the template text from your paper may result in your paper not being published.
\\
TODO: remove \verb|\usepackage{lipsum}| in the final
\end{document}
